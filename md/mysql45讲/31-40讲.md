### 33 我查这么多数据，会不会把数据库内存打爆？
全表扫描对server层的影响
对一个200G的表进行全表扫描。
“边读边发”
1）获取一行，写到net_buffer中
2）重复获取行，直到net_buffer写满，调用网络接口发出去
3）发送成功，清空net_buffer，然后读取下一行，并写入net_buffer
4）如果网络接口返回eagain或wsaewouldblock，本地网络栈(socket send buffer)写满了，进入等待。直到网络栈重新可写，再继续发送。

net_buffer大小由net_buffer_length定义，默认为16K
socket send buffer大小定义在 cat /proc/sys/net/core/wmem_default。 默认为208K

sending to client
1）show processlist中有进程一直是sending to client
### 34 到底可不可以使用join？
join时强制指定驱动表 `select * from t1 straight_join t2 on xxx`
#### NLJ算法
  两表join时用到了被驱动表的索引，我们称之为 Index Nested-Loop Join(索引) 。
过程：
```text
1)从驱动表t1读入一行数据R
2)从数据行R取出字段a到t2表去查找
3)取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分
4)重复执行步骤1)-3)步，直到表t1末尾循环结束。
复杂度： N + N*2*log2(M)   N：驱动表行数， M被驱动表行数
```
#### SNL算法
  两表join时未用到被驱动表索引，两表均走全表扫表，效率极低，我们称之为 Simple Nested-Loop Join(简单)。  
过程：
```text
过程如同 NLJ算法过程，只不过第3)步NLJ使用了被驱动表的索引，获取数据只需扫描一行，而simple nested-loop join算法用不到被驱动表的索引，获取数据需要扫描M行。
复杂度： N + N*M
```
#### BNL算法
  两表join且没法用到被驱动表的索引时，mysql进行了优化，将驱动表的数据先取出来，放入join_buffer中，然后逐行取被驱动表的数据，与join_buffer中的记录比对，我们称之为Block Nested-Loop Join(分段)。  
过程：
```text
1)把驱动表t1数据读入线程内存join_buffer，若放完第88行join_buffer满了，继续第2)步
2)扫描被驱动表t2，每一行取出来，跟join_buffer中的数据对比，满足join条件作为结果集的一部分返回
3)清空join_buffer
4)继续扫描表t1，顺序读取之后的12行放入join_buffer，继续执行第2)步
复杂度： 
1) 扫描行数： N+r*N*M
2) 内存中判断次数： N*M
N驱动表行数，r*N分段数K(所需驱动表字段数据量/join_buffer_size),r=(0,1)，M被驱动表行数
```
说明：
```text
join_buffer大小由join_buffer_size决定，默认256K
```
#### 总结
```text
1)如果可以使用被驱动表的索引，join语句有优势
2)不能使用被驱动表的索引，只能使用block nested-loop join算法，这样的语句慎用
3)join操作时，不论哪种算法，都应选择小表做驱动表
4)小表定义：两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数量，数据量小的那个表就是小表
```
### 35 join语句怎么优化？
#### MRR优化
```sql
select * from t1 where a>=1 and a<=1000;
```
说明：
```text
Multi-Range Read(MRR)优化
1）回表是一行一行搜索主键索引树并获取整行数据
2）“按行查”机制不能改，但可通过调整查询顺序来加速查询
3）优化设计思路： 大多数数据都是按照主键递增顺序插入得到的，所以如果按照主键递增顺序查询的话，对磁盘读比较接近顺序读，能提升性能。
```
语句执行流程：
```text
1）根据索引a定位到满足条件的记录，将id值放入read_rnd_buffer中。若read_rnd_buffer满了，继续执行2）3）4）步骤
2）将read_rnd_buffer中的id进行递增排序
3）排序后的id，依次到主键id索引中查记录，并作为结果返回。
4）清空read_rnd_buffer，重复1）2）3）步。
read_rnd_buffer大小由参数read_rnd_buffer_size控制,默认256K
```
配置：
```sql
-- 现在的优化器策略，更倾向于不使用MRR。以下配置固定使用MRR
optimizer_switch="mrr_cost_based=off"  
```
<font color='red'>MRR提升性能核心：</font>在索引a字段做范围查询，得到足够多的主键id，这样通过排序再去主键索引查数据，才能体现"顺序性"的优势。
#### BKA算法
```text
1）mysql5.6引入，Batched Key Access算法
2）NLJ算法的优化，在NLJ基础上利用MRR，就是BKA了
```
流程：
```text
1）从驱动表t1中取出全部1000行，放入join_buffer中
2）取出join_buffer中的字段a，利用a的范围查找检索被驱动表t2满足条件记录
3）检索表t2时利用MRR优化，可按主键id递增顺序获取数据，加速查询。
```
配置：
```sql
-- BKA算法的优化要依赖MRR
set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on'
```
#### BNL算法的性能问题
分析：
```text
被驱动表的数据量为M
1）若M<buffer_pool的3/8，能够完全放入old区域且执行语句超过1秒，再次扫描冷表时，会将冷表的数据页移动LRU链表头部(young区域)，挤压了热数据。
2）若M>buffer_pool的3/8，扫描冷表时，冷表的数据页将占满整个old区域，导致业务正常访问的数据页没法进入young区域，影响内存命中率
```
对系统性能的影响：
```text
1）可能会多次扫描被驱动表，占用磁盘IO资源
2）判断join条件需要执行M*N次对比，若是大表会占用非常多的CPU资源
3）会导致Buffer Pool的热数据被淘汰，影响内存命中率
```
#### BNL转BKA
```sql
select * from t1 join t2 on(t1.b=t2.b) and t2.b>=1 and t2.b<=2000;
```
优化方向：
```text
给被被驱动表的关联字段加上索引
1、在被驱动表的关联字段上建立索引
2、使用有索引的临时表
1）把被驱动表t2中满足条件的数据放在临时表temp_t中
2）为了让join使用BKA算法，给临时表字段b加上索引
3）让表t1和temp_t做join操作
```
sql语句：
```sql
create temporary table tmp_t(id int primary key,a int,b int, index(b))engine=innodb;
insert into temp_t select * from t2 where b>=1 and b<=2000;
select * from t1 join temp_t on(t1.b=temp_t.b);
```
#### 扩展hash-join
思路：
```text
1）select * from t1;取得表t1的全部1000行数据，在业务端存入hash结果，PHP数组
2）select * from t2 where b>=1 and b<=2000；获取表t2中满足条件的2000行数据
3）把2000行数据，一行一行取到业务端，到hash结构中找匹配的数据。满足条件，就作为结果集的一行。
mysql优化器和执行器不支持hash-join。
```

