### 34 到底可不可以使用join？
join时强制指定驱动表 from t1 straight_join t2 on xxx
#### NLJ算法
Index Nested-Loop Join(索引),-索引 两表join时用到了被驱动表的索引。
过程：
1)从驱动表t1读入一行R
2)从数据行R取出a字段到表t2去查找
3)取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分
4)重复执行步骤1-3，直到表t1末尾循环结束
复杂度 N + N*2*log2(M)

Simple Nested-Loop Join -简单
两表join时被驱动表没有索引
复杂度： N+N*M

Block Nested-Loop Join (BNL)-分段
join_buffer大小由`join_buffer_size`设定，默认256K
1)把被驱动表t1数据读入线程内存join_buffer中，若放完第88行join_buffer满了，继续第2)步
2)扫描表t2,每一行取出来，跟join_buffer中的数据对比，满足join条件的，作为结果集的一部分返回
3)清空join_buffer
4)继续扫描表t1,顺序读取之后的12行放入join_buffer中，继续执行第2)步
复杂度：
1) 扫描行数：N+r*N*M
2) 内存中判断次数： N*M
N驱动表行数,r*N分的段数K(r=(0,1)),K=floor(被驱动表数据量/join_buffer_size),M被驱动表行数

总结：
1)如果可以使用被驱动表的索引，join语句有优势
2)不能使用被驱动表的索引，只能使用Block Nested-Loop Join算法，这样的语句尽量不要使用
3)join操作时，不论用哪种算法，都应选择小表做驱动表
4)小表定义：两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表就是小表
### 35 join语句怎么优化？